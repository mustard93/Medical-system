/**
基于JTopo组件

*/
/**
  *
   * @Description: 基于JTopo组件，显示树形节点，自动布局。从左往右（布局），子节点往下。
   * @author liumingquan
   * @date 2016年12月15日 下午4:32:59

   修改记录：
      @Description: 多个节点显示是，有重叠情况。优化为不重叠
   * @author liumingquan
   * @date 2017年7月20日
  */'use strict';define("CanvasTreeLayout",["JTopo"],function(B){return{TreeLayout2:function(n,r,f,v,a,w,x){var y=f||30,p=v||30,z=w||20,A=x||20;return function(c){function f(h){for(var k=[],b=0;b<h.length;b++){var a=h[b];if(a instanceof n.Node){k.push(a);break}}return k}function t(h,a,b){b={x:b.x,y:b.y};if(a&&0!=a.length){"right-center"==r&&(b.y-=(a.length-1)/2*(a[0].height+p));for(var e=b.x,c=0;c<a.length;c++){var d=a[c];if(!d.hasSetLocation){d.hasSetLocation=!0;u.setRecord(b);d.setLocation(b.x,b.y);g.x<b.x&&(g.x=b.x);g.y<b.y&&(g.y=b.y);g=b;var l;l=h;var f=d.key,k=[];if(f)for(var q=0;q<l.length;q++){var m=l[q];m instanceof n.Node&&m.parentKey&&-1<m.parentKey.indexOf(f)&&k.push(m)}l=k;b.x=b.x+y+d.width;t(h,l,b);b.y+=p+d.height;for(b.x=e;u.isExistlocation(b);)b.y+=p+d.height}}}}var g={x:0,y:0},u={locationMap:{},_getKey:function(a){return"y"+a.y},isExistlocation:function(a){a=this._getKey(a);return 1==this.locationMap[a]},setRecord:function(a){a=this._getKey(a);this.locationMap[a]=!0}};a&&0!=a.length||(a=n.layout.getRootNodes(c.childs));a&&0!=a.length||(a=f(c.childs));var e={};"right-center"==r?(e=c.getCenterLocation(),e.x=10):(e.x=z,e.y=A);t(c.childs,a,e);return g}}}});